/-
Copyright (c) 2025 Yaël Dillies. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Yaël Dillies
-/
import Mathlib.GroupTheory.Finiteness
import Toric.Mathlib.Algebra.Group.Irreducible.Defs
import Mathlib.Algebra.Module.NatInt

/-!
# A salient affine monoid is generated by its irreducible elements
-/

variable {M : Type*} {S : Set M}

section AddCommMonoid
variable [AddCommMonoid M] [Subsingleton (AddUnits M)]

/-- Irreducible elements lie in all sets generating a salient monoid. -/
lemma addIrreducible_subset_of_addSubmonoidClosure_eq_top (hS : AddSubmonoid.closure S = ⊤) :
    {p | AddIrreducible p} ⊆ S := by
  have : ∀ {x : M} (hx : x ∈ AddSubmonoid.closure S), AddIrreducible x → x ∈ S :=
      AddSubmonoid.closure_induction (s := S) (p := fun x _ ↦ (AddIrreducible x → x ∈ S))
      (fun _ hx _ ↦ hx) (by simp) (fun a b _ _ ha hb h ↦ ?_)
  · exact fun x ↦ this (by rw [hS]; trivial)
  · obtain h₀ | h₀ := h.isAddUnit_or_isAddUnit rfl
    · obtain rfl := isAddUnit_iff_eq_zero.mp h₀
      rw [zero_add] at h ⊢
      exact hb h
    · obtain rfl := isAddUnit_iff_eq_zero.mp h₀
      rw [add_zero] at h ⊢
      exact ha h

variable [AddMonoid.FG M]

/-- A finitely generated salient monoid has finitely many irreducible elements. -/
lemma finite_addIrreducible : {p : M | AddIrreducible p}.Finite := by
  obtain ⟨S, hS⟩ := ‹AddMonoid.FG M›
  exact S.finite_toSet.subset <| addIrreducible_subset_of_addSubmonoidClosure_eq_top hS

end AddCommMonoid

section AddCancelCommMonoid
variable [AddCancelCommMonoid M] [AddMonoid.FG M] [Subsingleton (AddUnits M)] {S : Set M}

@[simp] lemma AddSubmonoid.closure_addIrreducible :
    AddSubmonoid.closure {p : M | AddIrreducible p} = ⊤ := by
  -- book proof is better? No, ur wrong
  classical
  have mingen :
      ∃ (S : Finset M),
        closure (S : Set M) = ⊤ ∧ ∀ (T : Set M), closure T = closure S → T ⊆ S → T = S := sorry
  obtain ⟨S, hSgen, hSmax⟩ := mingen
  suffices h : {x | AddIrreducible x} = S by rwa [h]
  by_contra h
  obtain ⟨-, r, hrS, hrirred⟩ := Set.ssubset_iff_exists.mp <| ssubset_of_subset_of_ne
    (addIrreducible_subset_of_addSubmonoidClosure_eq_top hSgen) h
  simp_rw [addIrreducible_iff] at hrirred
  simp only [Set.mem_setOf_eq, not_and, not_forall, Classical.not_imp, not_or] at hrirred
  obtain rfl | hr₀ := eq_or_ne r 0
  · specialize hSmax (S.toSet \ {0}) ?_ Set.diff_subset
    · refine eq_of_le_of_le (AddSubmonoid.closure_mono Set.diff_subset) <|
        AddSubmonoid.closure_le.mpr <| fun x hx ↦ ?_
      obtain rfl | hx₀ := eq_or_ne x 0
      · exact zero_mem (closure (S.toSet \ {0}))
      · have : x ∈ S.toSet \ {0} := Set.mem_diff_of_mem hx hx₀
        rw [SetLike.mem_coe, AddSubmonoid.mem_closure]
        exact fun N hN ↦ hN this
    have := Set.diff_singleton_sSubset.mpr hrS
    rw [hSmax] at this
    exact (and_not_self_iff (S ⊆ S)).mp this
  obtain ⟨a, b, hr, ha, hb⟩ := hrirred <| fun h ↦ hr₀ <| isAddUnit_iff_eq_zero.mp h
  have equation r (S : Finset M) : r ∈ closure S ↔ ∃ (m : M → ℕ), r = ∑ s ∈ S, m s • s := sorry
  obtain ⟨m, hm⟩ := (equation a S).mp (by rw [hSgen]; trivial)
  obtain ⟨n, hn⟩ := (equation b S).mp (by rw [hSgen]; trivial)
  have hm : a = m r • r + ∑ s ∈ S \ {r}, m s • s := sorry
  have hn : b = n r • r + ∑ s ∈ S \ {r}, n s • s := sorry
  have hr' : r = (m r + n r) • r + ∑ s ∈ S \ {r}, m s • s + ∑ s ∈ S \ {r}, n s • s := by
    rwa [add_smul, add_assoc, add_assoc, ← add_assoc (n r • r), add_comm (n r • r) _,
         add_assoc, ← hn, ← add_assoc, ← hm]

  match hr : m r + n r with
  | 0 =>
    specialize hSmax (S \ {r}) ?_ Set.diff_subset
    · refine eq_of_le_of_le (AddSubmonoid.closure_mono Set.diff_subset) <|
        AddSubmonoid.closure_le.mpr <| fun x hx ↦ ?_
      obtain rfl | hx₀ := eq_or_ne x r
      · rw [hr, zero_smul, zero_add] at hr'
        have hr' : x = ∑ s ∈ S \ {x}, (m s + n s) • s := sorry
        simpa using (equation _ _).mpr ⟨_, hr'⟩
      · have : x ∈ S.toSet \ {r} := Set.mem_diff_of_mem hx hx₀
        rw [SetLike.mem_coe, AddSubmonoid.mem_closure]
        exact fun N hN ↦ hN this
    have := Set.diff_singleton_sSubset.mpr hrS
    rw [hSmax] at this
    exact (and_not_self_iff (S ⊆ S)).mp this
  | 1 =>
    rw [hr, one_smul] at hr'
    -- have : 0 = ∑ s ∈ S \ {r}, (m s + n s) • (s : M) := add_left_cancel (by
    --   calc r + 0
    --     _ = r := add_zero r
    --     _ = r + ∑ s ∈ S \ {r}, (m s + n s) • (s : M) := hr')
    have nat_sum_one : ∀ (p q : ℕ), p + q = 1 → (p = 0 ∨ q = 0) := sorry -- surely this exists
    obtain h | h := nat_sum_one (m r) (n r) hr
    · rw [h, zero_smul, zero_add] at hm
      rw [h, zero_add] at hr
      rw [hr, one_smul] at hn
      refine ha ?_
      use {
        val := a
        neg := ∑ s ∈ S \ {r}, n s • s
        val_neg := add_left_cancel (by rw [← add_assoc, hm, ← hr', add_zero])
        neg_val := add_left_cancel (by rw [add_comm _ a, ← add_assoc, hm, ← hr', add_zero])
      }
    · rw [h, zero_smul, zero_add] at hn
      rw [h, add_zero] at hr
      rw [hr, one_smul] at hm
      refine hb ?_
      use {
        val := b
        neg := ∑ s ∈ S \ {r}, m s • s
        val_neg := add_left_cancel (a := r) (by rw [add_comm b _, ← add_assoc, hn, ← hr', add_zero])
        neg_val := add_left_cancel (by rw [← add_assoc, hn, ← hr', add_zero])
      }
  | N + 2 =>
    let rinv := N • r + ∑ s ∈ S \ {r}, m s • s + ∑ s ∈ S \ {r}, n s • s
    have hi : 0 = r + rinv := add_left_cancel (by
      calc r + 0
           _ = r := add_zero _
           _ = (m r + n r) • r + ∑ s ∈ S \ {r}, m s • s + ∑ s ∈ S \ {r}, n s • s := hr'
           _ = r + r + N • r + ∑ s ∈ S \ {r}, m s • s + ∑ s ∈ S \ {r}, n s • s := by
              rw [hr, add_smul (N + 1) 1 r, one_smul, add_comm _ r,
                  add_smul, one_smul, add_comm _ r, ← add_assoc]
           _ = r + (r + rinv) := by unfold rinv; rw [← add_assoc, ← add_assoc, ← add_assoc])
    have : IsAddUnit r := by
      let runit : AddUnits M := {
        val := r
        neg := rinv
        val_neg := hi.symm
        neg_val := by rw [add_comm, hi]
      }
      exact ⟨runit, rfl⟩
    exact hr₀ <| isAddUnit_iff_eq_zero.mp this

end AddCancelCommMonoid
